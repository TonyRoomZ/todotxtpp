(function() {
  define([], function() {
    var DUPE_PLACEHOLDER, TODO_PLACEHOLDER, actionUsage, actionsHelp, appendTodoFile, applyFilters, cleaninput, db, die, dieWithHelp, echo, env, exit, expand, filesystem, formattedDate, getNewTodo, getPrefix, getTodo, help, init, loadSourceVarOrTodoFile, loadTodoFile, oneline_usage, processConfig, read, regexpEscape, replaceOrPrepend, run, saveTodoFile, shorthelp, ui, usage, version, zeroFill;
    oneline_usage = env = filesystem = ui = echo = exit = db = read = {};
    TODO_PLACEHOLDER = '\t \t \t \t TODO PLACEHOLDER';
    DUPE_PLACEHOLDER = '\t \t \t \t DUPE PLACEHOLDER';
    applyFilters = function(filters, lines) {
      var line, passesAll;
      passesAll = function(filters, str) {
        var filter, _i, _len;
        for (_i = 0, _len = filters.length; _i < _len; _i++) {
          filter = filters[_i];
          if (filters.length > 0 && false) {
            console.log('\n\npassesAll()');
            console.log(str, filter);
            console.log(filter.test(str));
          }
          if (!filter.test(str)) {
            return false;
          }
        }
        return true;
      };
      if (filters.length > 0 && false) {
        console.log('lines:', lines);
      }
      return (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = lines.length; _i < _len; _i++) {
          line = lines[_i];
          if (passesAll(filters, line)) {
            _results.push(line);
          }
        }
        return _results;
      })();
    };
    Array.prototype.unique = function() {
      var key, output, value, _i, _ref, _results;
      output = {};
      for (key = _i = 0, _ref = this.length; 0 <= _ref ? _i < _ref : _i > _ref; key = 0 <= _ref ? ++_i : --_i) {
        output[this[key]] = this[key];
      }
      _results = [];
      for (key in output) {
        value = output[key];
        _results.push(value);
      }
      return _results;
    };
    expand = function(str) {
      return str != null ? str.replace(/\$[a-zA-Z_][a-zA-Z0-9_]*/g, function(s) {
        var _ref;
        return (_ref = env[s.slice(1)]) != null ? _ref : '';
      }) : void 0;
    };
    formattedDate = function(attachTime) {
      var date, result;
      date = new Date();
      if (env.TODO_TEST_TIME) {
        date = new Date(env.TODO_TEST_TIME * 1000 + date.getTimezoneOffset() * 60000);
      }
      result = ("" + (date.getFullYear()) + "-") + ("" + (zeroFill(date.getMonth() + 1, 2)) + "-") + ("" + (zeroFill(date.getDate(), 2)));
      if (attachTime != null) {
        result += ("T" + (zeroFill(date.getHours(), 2))) + (":" + (zeroFill(date.getMinutes(), 2))) + (":" + (zeroFill(date.getSeconds(), 2)));
      }
      return result;
    };
    loadSourceVarOrTodoFile = function() {
      var content, filename, filenames, _i, _len, _ref, _ref1;
      if (env.TODOTXT_SOURCEVAR != null) {
        filenames = env.TODOTXT_SOURCEVAR.replace(/[(")]/g, '');
        filenames = (_ref = filenames.split(' ')) != null ? _ref : [filenames];
        filenames = (function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = filenames.length; _i < _len; _i++) {
            filename = filenames[_i];
            _results.push(expand(filename));
          }
          return _results;
        })();
      } else {
        filenames = [env.TODO_FILE];
      }
      content = '';
      for (_i = 0, _len = filenames.length; _i < _len; _i++) {
        filename = filenames[_i];
        content += (_ref1 = filesystem.load(filename).trim()) != null ? _ref1 : '';
      }
      return content;
    };
    regexpEscape = function(str) {
      return str.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
    };
    zeroFill = function(number, width) {
      width -= number.toString().length;
      if (width > 0) {
        return new Array( width + (/\./.test( number ) ? 2 : 1) ).join( '0' ) + number;
      }
      return number;
    };
    loadTodoFile = function(filename) {
      var todos;
      if (filename == null) {
        filename = env.TODO_FILE;
      }
      todos = filesystem.load(filename);
      if (todos == null) {
        return null;
      }
      todos = ("" + TODO_PLACEHOLDER + "\n" + todos).split('\n');
      while (todos[todos.length - 1] === '') {
        todos.length--;
      }
      return todos;
    };
    saveTodoFile = function(todoItems, filename) {
      if (filename == null) {
        filename = env.TODO_FILE;
      }
      if (todoItems == null) {
        return false;
      }
      todoItems = (todoItems.slice(1).join('\n')) + '\n';
      return filesystem.save(filename, todoItems);
    };
    appendTodoFile = function(appendItems, filename) {
      var todos;
      if (appendItems == null) {
        return;
      }
      if (!(todos = loadTodoFile(filename))) {
        return;
      }
      todos = todos.concat(appendItems);
      return saveTodoFile(todos, filename);
    };
    processConfig = function(todoFileContents) {
      var exportArgs, line, name, path, touchFile, value, _i, _len, _ref, _ref1, _ref2, _results;
      _ref = todoFileContents.split('\n');
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        line = _ref[_i];
        line = line.replace(/^#.*/, '');
        if (touchFile = (_ref1 = line.match(/touch\s+(.*)/)) != null ? _ref1[1].trim() : void 0) {
          filesystem.save(touchFile, '');
        }
        if (exportArgs = line.match(/export\s+(.*)=(.*)/)) {
          _ref2 = exportArgs.slice(1, 4), name = _ref2[0], value = _ref2[1];
          path = filesystem.lastFilePath.match(/.*\//);
          value = value.replace(/\$\(\s*dirname\s+[\'\"]\$0[\'\"]\s*\)/, path);
          value = value.match(/^["']*(.*?)["']*$/)[1];
          value = expand(value);
          _results.push(env[name] = value);
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };
    version = function() {
      echo("TODO.HTML Command Line Interface v0.2.9.4alpha\n\nFirst release: 05/17/2012\nDeveloped by: John-Kim Murphy (http://Leftium.com)\nCode repository: https://github.com/leftium/todo.html\n\nBased on idea by: Gina Trapani (http://ginatrapani.org)\nLicense: GPL http://www.gnu.org/copyleft/gpl.html");
      return exit(1);
    };
    init = function(_env, _filesystem, _ui, _system) {
      env = _env;
      filesystem = _filesystem;
      ui = _ui;
      echo = ui.echo;
      read = ui.ask;
      db = _system.db;
      exit = _system.exit;
      return oneline_usage = "" + env.TODO_SH + " [-fhpantvV] [-d todo_config] action [task_number] [task_description]";
    };
    usage = function() {
      echo("Usage: " + oneline_usage + "\nTry '" + env.TODO_SH + " -h' for more information.");
      return exit(1);
    };
    shorthelp = function() {
      return echo("\  Usage: " + oneline_usage + "\n\n  Actions:\n    add|a \"THING I NEED TO DO +project @context\"\n    addm \"THINGS I NEED TO DO\n          MORE THINGS I NEED TO DO\"\n    addto DEST \"TEXT TO ADD\"\n    append|app ITEM# \"TEXT TO APPEND\"\n    archive\n    command [ACTIONS]\n    deduplicate\n    del|rm ITEM# [TERM]\n    depri|dp ITEM#[, ITEM#, ITEM#, ...]\n    do ITEM#[, ITEM#, ITEM#, ...]\n    help\n    help [ACTION...]\n    list|ls [TERM...]\n    listall|lsa [TERM...]\n    listaddons\n    listcon|lsc [TERM...]\n    listfile|lf [SRC [TERM...]]\n    listpri|lsp [PRIORITIES] [TERM...]\n    listproj|lsprj [TERM...]\n    move|mv ITEM# DEST [SRC]\n    prepend|prep ITEM# \"TEXT TO PREPEND\"\n    pri|p ITEM# PRIORITY\n    replace ITEM# \"UPDATED TODO\"\n    report\n    shorthelp\n\n  Actions can be added and overridden using scripts in the actions\n  See \"help\" for more details.");
    };
    help = function() {
      echo("\  Usage: " + oneline_usage + "\n\n  Options:\n    -@\n        Hide context names in list output.  Use twice to show context\n        names (default).\n    -+\n        Hide project names in list output.  Use twice to show project\n        names (default).\n    -c\n        Color mode\n    -d CONFIG_FILE\n        Use a configuration file other than the default ~/.todo/config\n    -f\n        Forces actions without confirmation or interactive input\n    -h\n        Display a short help message; same as action \"shorthelp\"\n    -p\n        Plain mode turns off colors\n    -P\n        Hide priority labels in list output.  Use twice to show\n        priority labels (default).\n    -a\n        Don't auto-archive tasks automatically on completion\n    -A\n        Auto-archive tasks automatically on completion\n    -n\n        Don't preserve line numbers; automatically remove blank lines\n        on task deletion\n    -N\n        Preserve line numbers\n    -t\n        Prepend the current date to a task automatically\n        when it's added.\n    -T\n        Do not prepend the current date to a task automatically\n        when it's added.\n    -v\n        Verbose mode turns on confirmation messages\n    -vv\n        Extra verbose mode prints some debugging information and\n        additional help text\n    -V\n        Displays version, license and credits\n    -x\n        Disables TODOTXT_FINAL_FILTER\n\n");
      if (env.TODOTXT_VERBOSE > 1) {
        echo("\  Environment variables:\n    TODOTXT_AUTO_ARCHIVE            is same as option -a (0)/-A (1)\n    TODOTXT_CFG_FILE=CONFIG_FILE    is same as option -d CONFIG_FILE\n    TODOTXT_FORCE=1                 is same as option -f\n    TODOTXT_PRESERVE_LINE_NUMBERS   is same as option -n (0)/-N (1)\n    TODOTXT_PLAIN                   is same as option -p (1)/-c (0)\n    TODOTXT_DATE_ON_ADD             is same as option -t (1)/-T (0)\n    TODOTXT_VERBOSE=1               is same as option -v\n    TODOTXT_DISABLE_FILTER=1        is same as option -x\n    TODOTXT_DEFAULT_ACTION=\"\"       run this when called with no arguments\n    TODOTXT_SORT_COMMAND=\"sort ...\" customize list output\n    TODOTXT_FINAL_FILTER=\"sed ...\"  customize list after color, P@+ hiding\n    TODOTXT_SOURCEVAR=$DONE_FILE   use another source for listcon, listproj\n");
      }
      echo(actionsHelp());
      return exit(1);
    };
    actionsHelp = function() {
      return "\  Built-in Actions:\n    add \"THING I NEED TO DO +project @context\"\n    a \"THING I NEED TO DO +project @context\"\n      Adds THING I NEED TO DO to your todo.txt file on its own line.\n      Project and context notation optional.\n      Quotes optional.\n\n    addm \"FIRST THING I NEED TO DO +project1 @context\n    SECOND THING I NEED TO DO +project2 @context\"\n      Adds FIRST THING I NEED TO DO to your todo.txt on its own line and\n      Adds SECOND THING I NEED TO DO to you todo.txt on its own line.\n      Project and context notation optional.\n\n    addto DEST \"TEXT TO ADD\"\n      Adds a line of text to any file located in the todo.txt directory.\n      For example, addto inbox.txt \"decide about vacation\"\n\n    append ITEM# \"TEXT TO APPEND\"\n    app ITEM# \"TEXT TO APPEND\"\n      Adds TEXT TO APPEND to the end of the task on line ITEM#.\n      Quotes optional.\n\n    archive\n      Moves all done tasks from todo.txt to done.txt and removes blank lines.\n\n    command [ACTIONS]\n      Runs the remaining arguments using only todo.sh builtins.\n      Will not call any .todo.actions.d scripts.\n\n    deduplicate\n      Removes duplicate lines from todo.txt.\n\n    del ITEM# [TERM]\n    rm ITEM# [TERM]\n      Deletes the task on line ITEM# in todo.txt.\n      If TERM specified, deletes only TERM from the task.\n\n    depri ITEM#[, ITEM#, ITEM#, ...]\n    dp ITEM#[, ITEM#, ITEM#, ...]\n      Deprioritizes (removes the priority) from the task(s)\n      on line ITEM# in todo.txt.\n\n    do ITEM#[, ITEM#, ITEM#, ...]\n      Marks task(s) on line ITEM# as done in todo.txt.\n\n    help [ACTION...]\n      Display help about usage, options, built-in actions,\n      or just the usage help for the passed ACTION(s).\n\n    list [TERM...]\n    ls [TERM...]\n      Displays all tasks that contain TERM(s) sorted by priority with line\n      numbers.  Each task must match all TERM(s) (logical AND); to display\n      tasks that contain any TERM (logical OR), use\n      \"TERM1|TERM2|...\" (with quotes), or TERM1\|TERM2 (unquoted).\n      Hides all tasks that contain TERM(s) preceded by a\n      minus sign (i.e. -TERM). If no TERM specified, lists entire todo.txt.\n\n    listall [TERM...]\n    lsa [TERM...]\n      Displays all the lines in todo.txt AND done.txt that contain TERM(s)\n      sorted by priority with line  numbers.  Hides all tasks that\n      contain TERM(s) preceded by a minus sign (i.e. -TERM).  If no\n      TERM specified, lists entire todo.txt AND done.txt\n      concatenated and sorted.\n\n    listaddons\n      Lists all added and overridden actions in the actions directory.\n\n    listcon\n    lsc\n    listcon [TERM...]\n    lsc [TERM...]\n      Lists all the task contexts that start with the @ sign in todo.txt.\n      If TERM specified, considers only tasks that contain TERM(s).\n\n    listfile [SRC [TERM...]]\n    lf [SRC [TERM...]]\n      Displays all the lines in SRC file located in the todo.txt directory,\n      sorted by priority with line  numbers.  If TERM specified, lists\n      all lines that contain TERM(s) in SRC file.  Hides all tasks that\n      contain TERM(s) preceded by a minus sign (i.e. -TERM).\n      Without any arguments, the names of all text files in the todo.txt\n      directory are listed.\n\n    listpri [PRIORITIES] [TERM...]\n    lsp [PRIORITIES] [TERM...]\n      Displays all tasks prioritized PRIORITIES.\n      PRIORITIES can be a single one (A) or a range (A-C).\n      If no PRIORITIES specified, lists all prioritized tasks.\n      If TERM specified, lists only prioritized tasks that contain TERM(s).\n      Hides all tasks that contain TERM(s) preceded by a minus sign\n      (i.e. -TERM).\n\n    listproj\n    lsprj\n      Lists all the projects (terms that start with a + sign) in\n      todo.txt.\n\n    move ITEM# DEST [SRC]\n    mv ITEM# DEST [SRC]\n      Moves a line from source text file (SRC) to destination text file (DEST).\n      Both source and destination file must be located in the directory defined\n      in the configuration directory.  When SRC is not defined\n      it's by default todo.txt.\n\n    prepend ITEM# \"TEXT TO PREPEND\"\n    prep ITEM# \"TEXT TO PREPEND\"\n      Adds TEXT TO PREPEND to the beginning of the task on line ITEM#.\n      Quotes optional.\n\n    pri ITEM# PRIORITY\n    p ITEM# PRIORITY\n      Adds PRIORITY to task on line ITEM#.  If the task is already\n      prioritized, replaces current priority with new PRIORITY.\n      PRIORITY must be a letter between A and Z.\n\n    replace ITEM# \"UPDATED TODO\"\n      Replaces task on line ITEM# with UPDATED TODO.\n\n    report\n      Adds the number of open tasks and done tasks to report.txt.\n\n    shorthelp\n      List the one-line usage of all built-in and add-on actions.\n";
    };
    actionUsage = function(actionNames) {
      var actionName, builtinActionUsage, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = actionNames.length; _i < _len; _i++) {
        actionName = actionNames[_i];
        builtinActionUsage = actionsHelp().match(RegExp("^\\s\\s\\s\\s" + actionName + "\\s[\\s\\S]*?^$", "m"));
        if (builtinActionUsage) {
          _results.push(echo(builtinActionUsage[0]));
        } else {
          _results.push(die("TODO: No action \"" + actionName + "\" exists."));
        }
      }
      return _results;
    };
    dieWithHelp = function(command, msg) {
      switch (command) {
        case 'help':
          help();
          break;
        case 'shorthelp':
          shorthelp();
      }
      return die(msg);
    };
    die = function(msg) {
      echo(msg);
      return exit(1);
    };
    cleaninput = function(input) {
      input = input.replace(/\r/g, ' ');
      input = input.replace(/\n/g, ' ');
      return input;
    };
    getPrefix = function(filename) {
      var _ref;
      if (filename == null) {
        filename = env.TODO_FILE;
      }
      return filename != null ? (_ref = filename.replace(/^.*\/|\.[^.]*$/g, '')) != null ? _ref.toUpperCase() : void 0 : void 0;
    };
    getTodo = function(item, todoFile) {
      var todo, _ref;
      if (todoFile == null) {
        todoFile = env.TODO_FILE;
      }
      if (!item) {
        die(env.errmsg);
      }
      if (/[^0-9]/.test(item)) {
        die(env.errmsg);
      }
      todo = (_ref = loadTodoFile(todoFile)) != null ? _ref[parseInt(item)] : void 0;
      if (!todo) {
        die("" + (getPrefix(todoFile)) + ": No task " + item + ".");
      }
      return todo;
    };
    getNewTodo = function() {};
    replaceOrPrepend = function(action, argv) {
      var backref, input, item, matches, newtodo, prepdate, priority, querytext, todo, todos, _ref, _ref1;
      switch (action) {
        case 'replace':
          backref = '';
          querytext = "Replacement: ";
          break;
        case 'prepend':
          backref = ' $&';
          querytext = "Prepend: ";
      }
      argv.shift();
      item = argv.shift();
      todo = getTodo(item);
      if (!argv[0] && env.TODOTXT_FORCE === 0) {
        input = read(querytext);
      } else {
        input = argv.slice(0).join(' ');
      }
      input = cleaninput(input);
      matches = todo.match(/^(\(.\) ){0,1}([0-9]{2,4}-[0-9]{2}-[0-9]{2} ){0,1}.*/);
      priority = (_ref = matches != null ? matches[1] : void 0) != null ? _ref : '';
      prepdate = (_ref1 = matches != null ? matches[2] : void 0) != null ? _ref1 : '';
      if (prepdate && action === "replace" && /^(\(.\) ){0,1}[0-9]{2,4}-[0-9]{2}-[0-9]{2}/.test(input)) {
        prepdate = '';
      }
      newtodo = todo.replace(new RegExp("^" + (regexpEscape(priority)) + prepdate), '').replace(/.*/, "" + priority + prepdate + input + backref);
      if (todos = loadTodoFile()) {
        todos[parseInt(item)] = newtodo;
        saveTodoFile(todos);
      }
      if (env.TODOTXT_VERBOSE > 0) {
        switch (action) {
          case 'replace':
            echo("" + item + " " + todo);
            echo("TODO: Replaced task with:");
            return echo("" + item + " " + newtodo);
          case 'prepend':
            return echo("" + item + " " + newtodo);
        }
      }
    };
    run = function(argv) {
      var $3, action, allItems, answer, appendspace, clr, config, context, contexts, d, deduplicateNum, dest, doneItems, donenum, dones, dupe, file, filtercommand, filters, getPadding, i, input, item, lastdata, lastreport, line, newTaskNum, newdata, newpri, newreport, newtodo, now, oldpri, option, optreset, originalTaskNum, padding, pri, project, projects, shellquote, t, tasknum, tdone, todo, todoItems, todos, total, _addto, _format, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _len6, _len7, _len8, _list, _m, _n, _o, _p, _q, _r, _ref, _ref1, _ref10, _ref11, _ref12, _ref13, _ref14, _ref15, _ref16, _ref17, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9;
      env.OVR_TODOTXT_AUTO_ARCHIVE = env.TODOTXT_AUTO_ARCHIVE;
      env.OVR_TODOTXT_FORCE = env.TODOTXT_FORCE;
      env.OVR_TODOTXT_PRESERVE_LINE_NUMBERS = env.TODOTXT_PRESERVE_LINE_NUMBERS;
      env.OVR_TODOTXT_PLAIN = env.TODOTXT_PLAIN;
      env.OVR_TODOTXT_DATE_ON_ADD = env.TODOTXT_DATE_ON_ADD;
      env.OVR_TODOTXT_VERBOSE = env.TODOTXT_VERBOSE;
      env.OVR_TODOTXT_DEFAULT_ACTION = env.TODOTXT_DEFAULT_ACTION;
      resetopt();
      while ((option = getopt(argv, ':fhpcnNaAtTvVx+@Pd:')) !== '') {
        switch (option) {
          case '@':
            if (env.HIDE_CONTEXT_NAMES == null) {
              env.HIDE_CONTEXT_NAMES = 0;
            }
            env.HIDE_CONTEXT_NAMES++;
            if (env.HIDE_CONTEXT_NAMES % 2 === 0) {
              env.HIDE_CONTEXTS_SUBSTITUTION = /^/;
            } else {
              env.HIDE_CONTEXTS_SUBSTITUTION = /\s@[\x21-\x7E]{1,}/g;
            }
            break;
          case '+':
            if (env.HIDE_PROJECT_NAMES == null) {
              env.HIDE_PROJECT_NAMES = 0;
            }
            env.HIDE_PROJECT_NAMES++;
            if (env.HIDE_PROJECT_NAMES % 2 === 0) {
              env.HIDE_PROJECTS_SUBSTITUTION = /^/;
            } else {
              env.HIDE_PROJECTS_SUBSTITUTION = /\s[+][\x21-\x7E]{1,}/g;
            }
            break;
          case 'a':
            env.OVR_TODOTXT_AUTO_ARCHIVE = 0;
            break;
          case 'A':
            env.OVR_TODOTXT_AUTO_ARCHIVE = 1;
            break;
          case 'c':
            env.OVR_TODOTXT_PLAIN = 0;
            break;
          case 'd':
            env.TODOTXT_CFG_FILE = optarg;
            break;
          case 'f':
            env.OVR_TODOTXT_FORCE = 1;
            break;
          case 'h':
            argv = ['-h', 'shorthelp'];
            optreset = true;
            break;
          case 'n':
            env.OVR_TODOTXT_PRESERVE_LINE_NUMBERS = 0;
            break;
          case 'N':
            env.OVR_TODOTXT_PRESERVE_LINE_NUMBERS = 1;
            break;
          case 'p':
            env.OVR_TODOTXT_PLAIN = 1;
            break;
          case 'P':
            if (env.HIDE_PRIORITY_LABELS == null) {
              env.HIDE_PRIORITY_LABELS = 0;
            }
            env.HIDE_PRIORITY_LABELS++;
            if (env.HIDE_PRIORITY_LABELS % 2 === 0) {
              env.HIDE_PRIORITY_SUBSTITUTION = /^\(\)/;
            } else {
              env.HIDE_PRIORITY_SUBSTITUTION = /([0-9]+ )\([A-Z]\)\s/;
            }
            break;
          case 't':
            env.OVR_TODOTXT_DATE_ON_ADD = 1;
            break;
          case 'T':
            env.OVR_TODOTXT_DATE_ON_ADD = 0;
            break;
          case 'v':
            if (env.TODOTXT_VERBOSE == null) {
              env.TODOTXT_VERBOSE = 0;
            }
            env.TODOTXT_VERBOSE++;
            break;
          case 'V':
            version();
            break;
          case 'x':
            false;
            break;
          case ':':
            echo("Error - Option needs a value: " + optopt);
            return 1;
          case '?':
            echo("Error - No such option: " + optopt);
            return 1;
          default:
            echo("Error - Option not implemented yet: " + optopt);
            console.log(option);
            return 1;
        }
      }
      for (_i = 0; 0 <= optind ? _i < optind : _i > optind; 0 <= optind ? _i++ : _i--) {
        argv.shift();
      }
      if (env.TODOTXT_VERBOSE == null) {
        env.TODOTXT_VERBOSE = 1;
      }
      if (env.TODOTXT_PLAIN == null) {
        env.TODOTXT_PLAIN = 0;
      }
      if (env.TODOTXT_CFG_FILE == null) {
        env.TODOTXT_CFG_FILE = env.HOME + '/.todo/config';
      }
      if (env.TODOTXT_FORCE == null) {
        env.TODOTXT_FORCE = 0;
      }
      if (env.TODOTXT_PRESERVE_LINE_NUMBERS == null) {
        env.TODOTXT_PRESERVE_LINE_NUMBERS = 1;
      }
      if (env.TODOTXT_AUTO_ARCHIVE == null) {
        env.TODOTXT_AUTO_ARCHIVE = 1;
      }
      if (env.TODOTXT_DATE_ON_ADD == null) {
        env.TODOTXT_DATE_ON_ADD = 0;
      }
      if (env.TODOTXT_DEFAULT_ACTION == null) {
        env.TODOTXT_DEFAULT_ACTION = '';
      }
      env.NONE = '';
      env.BLACK = '\\033[0;30m';
      env.RED = '\\033[0;31m';
      env.GREEN = '\\033[0;32m';
      env.BROWN = '\\033[0;33m';
      env.BLUE = '\\033[0;34m';
      env.PURPLE = '\\033[0;35m';
      env.CYAN = '\\033[0;36m';
      env.LIGHT_GREY = '\\033[0;37m';
      env.DARK_GREY = '\\033[1;30m';
      env.LIGHT_RED = '\\033[1;31m';
      env.LIGHT_GREEN = '\\033[1;32m';
      env.YELLOW = '\\033[1;33m';
      env.LIGHT_BLUE = '\\033[1;34m';
      env.LIGHT_PURPLE = '\\033[1;35m';
      env.LIGHT_CYAN = '\\033[1;36m';
      env.WHITE = '\\033[1;37m';
      env.DEFAULT = '\\033[0m';
      env.PRI_A = env.YELLOW;
      env.PRI_B = env.GREEN;
      env.PRI_C = env.LIGHT_BLUE;
      env.PRI_X = env.WHITE;
      env.COLOR_DONE = env.LIGHT_GREY;
      env.SENTENCE_DELIMITERS = ',.:;';
      config = filesystem.load(env.TODOTXT_CFG_FILE);
      if (config == null) {
        config = filesystem.load("" + env.HOME + "/todo.cfg");
      }
      if (config == null) {
        config = filesystem.load("" + env.HOME + "/.todo.cfg");
      }
      if (config == null) {
        config = filesystem.load("" + env.DEFAULT_TODO_DIR + "/todo.cfg");
      }
      if (!config) {
        dieWithHelp(argv[0], "Fatal Error: Cannot read configuration file " + env.TODOTXT_CFG_FILE);
      }
      processConfig(config);
      if (env.OVR_TODOTXT_AUTO_ARCHIVE != null) {
        env.TODOTXT_AUTO_ARCHIVE = env.OVR_TODOTXT_AUTO_ARCHIVE;
      }
      if (env.OVR_TODOTXT_FORCE != null) {
        env.TODOTXT_FORCE = env.OVR_TODOTXT_FORCE;
      }
      if (env.OVR_TODOTXT_PRESERVE_LINE_NUMBERS != null) {
        env.TODOTXT_PRESERVE_LINE_NUMBERS = env.OVR_TODOTXT_PRESERVE_LINE_NUMBERS;
      }
      if (env.OVR_TODOTXT_PLAIN != null) {
        env.TODOTXT_PLAIN = env.OVR_TODOTXT_PLAIN;
      }
      if (env.OVR_TODOTXT_DATE_ON_ADD != null) {
        env.TODOTXT_DATE_ON_ADD = env.OVR_TODOTXT_DATE_ON_ADD;
      }
      if (env.OVR_TODOTXT_VERBOSE != null) {
        env.TODOTXT_VERBOSE = env.OVR_TODOTXT_VERBOSE;
      }
      if (env.OVR_TODOTXT_DEFAULT_ACTION != null) {
        env.TODOTXT_DEFAULT_ACTION = env.OVR_TODOTXT_DEFAULT_ACTION;
      }
      action = (_ref = argv[0]) != null ? _ref : env.TODOTXT_DEFAULT_ACTION;
      if (!action) {
        usage();
      }
      if (filesystem.load(env.TODO_FILE) == null) {
        filesystem.save(env.TODO_FILE, '');
      }
      if (filesystem.load(env.DONE_FILE) == null) {
        filesystem.save(env.DONE_FILE, '');
      }
      if (filesystem.load(env.REPORT_FILE) == null) {
        filesystem.save(env.REPORT_FILE, '');
      }
      if (env.TODOTXT_PLAIN) {
        for (clr in env) {
          if (clr.match(/^PRI_/)) {
            env[clr] = env.NONE;
          }
        }
        env.PRI_X = env.NONE;
        env.DEFAULT = env.NONE;
        env.COLOR_DONE = env.NONE;
      }
      _addto = function(file, input) {
        var now, tasknum, todos;
        input = cleaninput(input);
        if (env.TODOTXT_DATE_ON_ADD) {
          now = formattedDate();
          input = input.replace(/^(\([A-Z]\) ){0,1}/i, "$1" + now + " ");
        }
        todos = loadTodoFile(file);
        todos.push(input);
        saveTodoFile(todos, file);
        if (env.TODOTXT_VERBOSE > 0) {
          tasknum = todos.length - 1;
          echo("" + tasknum + " " + input);
          return echo("" + (getPrefix(file)) + ": " + tasknum + " added.");
        }
      };
      shellquote = function(str) {
        return str.replace(/[-\{}()+?,\\^$|#\s]/g, '\\$&');
      };
      filtercommand = function(pre_filter, post_filter, search_terms) {
        var filters, search_term, _j, _len;
        filters = [];
        for (_j = 0, _len = search_terms.length; _j < _len; _j++) {
          search_term = search_terms[_j];
          if (search_term[0] !== '-') {
            filters.push(new RegExp(shellquote(search_term), 'i'));
          } else {
            filters.push(new RegExp("^(?!.*" + (shellquote(search_term.slice(1))) + ")", 'i'));
          }
        }
        if (post_filter) {
          filters.push(post_filter);
        }
        return filters;
      };
      _list = function(file, searchTerms, postFilterRegexp) {
        var src;
        if (file[0] === '/') {
          src = file;
        } else if (filesystem.load("" + env.TODO_DIR + "/" + file) != null) {
          src = "" + env.TODO_DIR + "/" + file;
        } else if (filesystem.load(file) != null) {
          src = file;
        } else if (filesystem.load("" + env.TODO_DIR + "/" + file + ".txt") != null) {
          src = "" + env.TODO_DIR + "/" + file + ".txt";
        } else {
          die("TODO: File " + file + " does not exist.");
        }
        _format(loadTodoFile(src), null, searchTerms, postFilterRegexp);
        if (env.TODOTXT_VERBOSE > 0) {
          echo("--");
          return echo("" + (getPrefix(src)) + ": " + env.numTasks + " of " + env.totalTasks + " tasks shown");
        }
      };
      getPadding = function(items) {
        var lines;
        lines = String(items.length - 1);
        return lines.length;
      };
      _format = function(items, padding, terms, postFilterRegexp) {
        var filteredItems, filters, highlight, i, item, level, nonemptyItems, num, stopNumbering, _j, _k, _l, _len, _len1, _len2, _len3, _m, _ref1;
        if (padding == null) {
          padding = getPadding(items);
        }
        items = items.slice(1);
        nonemptyItems = [];
        for (i = _j = 0, _len = items.length; _j < _len; i = ++_j) {
          item = items[i];
          if (/[\x21-\x7E]/.test(item)) {
            if (item === TODO_PLACEHOLDER) {
              stopNumbering = true;
            } else {
              if (stopNumbering != null) {
                num = 0;
              } else {
                num = i + 1;
              }
              nonemptyItems.push("" + (zeroFill(num, padding)) + " " + item);
            }
          }
        }
        filters = filtercommand('', postFilterRegexp, terms);
        filteredItems = [];
        if (filters.length) {
          filteredItems = applyFilters(filters, nonemptyItems);
        } else {
          filteredItems = nonemptyItems;
        }
        filteredItems = filteredItems.sort(function(a, b) {
          var k;
          k = padding + 1;
          a = a.slice(k).toUpperCase();
          b = b.slice(k).toUpperCase();
          if (a <= b) {
            return -1;
          } else {
            return 1;
          }
        });
        highlight = function(colorVar) {
          var color, _ref1;
          color = (_ref1 = env[colorVar.toUpperCase()]) != null ? _ref1 : env.PRI_X;
          color = color.replace(/\\+033/i, '\033');
          return color;
        };
        for (i = _k = 0, _len1 = filteredItems.length; _k < _len1; i = ++_k) {
          item = filteredItems[i];
          if (/^[0-9]+ x/.test(item)) {
            item = highlight('COLOR_DONE') + item + highlight('DEFAULT');
          }
          if (level = (_ref1 = item.match(/^[0-9]+ \(([A-Z])\)/i)) != null ? _ref1[1] : void 0) {
            item = highlight('PRI_' + level) + item + highlight('DEFAULT');
          }
          filteredItems[i] = item;
        }
        for (i = _l = 0, _len2 = filteredItems.length; _l < _len2; i = ++_l) {
          item = filteredItems[i];
          item = item.replace(env.HIDE_PROJECTS_SUBSTITUTION, '');
          item = item.replace(env.HIDE_CONTEXTS_SUBSTITUTION, '');
          item = item.replace(env.HIDE_PRIORITY_SUBSTITUTION, '$1');
          item = item.replace(new RegExp(env.HIDE_CUSTOM_SUBSTITUTION, 'g'), '');
          filteredItems[i] = item;
        }
        for (_m = 0, _len3 = filteredItems.length; _m < _len3; _m++) {
          item = filteredItems[_m];
          echo(item);
        }
        if (env.TODOTXT_VERBOSE > 0) {
          env.numTasks = filteredItems.length;
          env.totalTasks = nonemptyItems.length;
        }
        if (env.TODOTXT_VERBOSE > 1) {
          echo('TODO DEBUG: Filters used were:');
          echo(filters);
        }
        return filteredItems.length;
      };
      action = action != null ? action.toLowerCase() : void 0;
      if (action === 'command') {
        argv.shift();
        action = (_ref1 = argv[0]) != null ? _ref1.toLowerCase() : void 0;
      }
      switch (action) {
        case 'add':
        case 'a':
          if (!argv[1] && env.TODOTXT_FORCE === 0) {
            input = read('Add: ');
          } else {
            if (!argv[1]) {
              die("usage: " + env.TODO_SH + " add \"TODO ITEM\"");
            }
            argv.shift();
            input = argv.join(' ');
          }
          _addto(env.TODO_FILE, input);
          break;
        case 'addm':
          if (!argv[1] && env.TODOTXT_FORCE === 0) {
            input = read('Add: ');
          } else {
            if (!argv[1]) {
              die("usage: " + env.TODO_SH + " addm \"TODO ITEM\"");
            }
            argv.shift();
            input = argv.join(' ');
          }
          _ref2 = input.split('\n');
          for (_j = 0, _len = _ref2.length; _j < _len; _j++) {
            line = _ref2[_j];
            _addto(env.TODO_FILE, line);
          }
          break;
        case 'addto':
          if (!argv[1]) {
            die("usage: " + env.TODO_SH + " addto DEST \"TODO ITEM\"");
          }
          dest = "" + env.TODO_DIR + "/" + argv[1];
          if (!argv[2]) {
            die("usage: " + env.TODO_SH + " addto DEST \"TODO ITEM\"");
          }
          argv.shift();
          argv.shift();
          input = argv.join(' ');
          if (filesystem.load(dest) != null) {
            _addto(dest, input);
          } else {
            die("TODO: Destination file " + dest + " does not exist.");
          }
          break;
        case 'append':
        case 'app':
          env.errmsg = "usage: " + env.TODO_SH + " append ITEM# \"TEXT TO APPEND\"";
          argv.shift();
          item = argv.shift();
          todo = getTodo(item);
          if (!argv[0] && env.TODOTXT_FORCE === 0) {
            input = read('Append: ');
          } else {
            input = argv.join(' ');
          }
          if (env.SENTENCE_DELIMITERS.indexOf(input[0]) !== -1) {
            appendspace = '';
          } else {
            appendspace = ' ';
          }
          input = cleaninput(input);
          newtodo = todo.replace(/^.*/, "$&" + appendspace + input);
          if (todos = loadTodoFile(env.TODO_FILE)) {
            todos[parseInt(item, 10)] = newtodo;
            if (saveTodoFile(todos, env.TODO_FILE)) {
              if (env.TODOTXT_VERBOSE > 0) {
                echo("" + item + " " + newtodo);
              }
            } else {
              die("TODO: Error appending task " + item + ".");
            }
          }
          break;
        case 'archive':
          if (todos = loadTodoFile()) {
            todos = (function() {
              var _k, _len1, _results;
              _results = [];
              for (_k = 0, _len1 = todos.length; _k < _len1; _k++) {
                item = todos[_k];
                if (item !== '') {
                  _results.push(item);
                }
              }
              return _results;
            })();
            dones = (function() {
              var _k, _len1, _results;
              _results = [];
              for (_k = 0, _len1 = todos.length; _k < _len1; _k++) {
                item = todos[_k];
                if (/^x /.test(item)) {
                  _results.push(item);
                }
              }
              return _results;
            })();
            if (env.TODOTXT_VERBOSE > 0) {
              for (_k = 0, _len1 = dones.length; _k < _len1; _k++) {
                item = dones[_k];
                echo(item);
              }
            }
            appendTodoFile(dones, env.DONE_FILE);
            saveTodoFile((function() {
              var _l, _len2, _results;
              _results = [];
              for (_l = 0, _len2 = todos.length; _l < _len2; _l++) {
                item = todos[_l];
                if (!/^x /.test(item)) {
                  _results.push(item);
                }
              }
              return _results;
            })());
            echo("TODO: " + env.TODO_FILE + " archived.");
          }
          break;
        case 'del':
        case 'rm':
          env.errmsg = "usage: " + env.TODO_SH + " del ITEM# [TERM]";
          item = argv[1];
          todo = getTodo(item);
          item = parseInt(item, 10);
          if (!argv[2]) {
            if (env.TODOTXT_FORCE === 0) {
              answer = read("Delete " + todo + "? (y/n)");
            } else {
              answer = "y";
            }
            if (answer === 'y') {
              todos = loadTodoFile();
              todos[item] = '';
              while (todos[todos.length - 1] === '') {
                todos.length--;
              }
              if (env.TODOTXT_PRESERVE_LINE_NUMBERS === 0) {
                todos = (function() {
                  var _l, _len2, _results;
                  _results = [];
                  for (_l = 0, _len2 = todos.length; _l < _len2; _l++) {
                    t = todos[_l];
                    if (t !== '') {
                      _results.push(t);
                    }
                  }
                  return _results;
                })();
              }
              saveTodoFile(todos);
              if (env.TODOTXT_VERBOSE > 0) {
                echo("" + item + " " + todo);
                echo("TODO: " + item + " deleted.");
              }
            } else {
              echo("TODO: No tasks were deleted.");
            }
          } else {
            $3 = argv[2];
            newtodo = todo.replace(new RegExp("^(\(.\) ){0,1} *" + $3 + " *", 'g'), '$1').replace(new RegExp(" *" + $3 + " *$", 'g'), '').replace(new RegExp("  *" + $3 + " *", 'g'), ' ').replace(new RegExp(" *" + $3 + "  *", 'g'), ' ').replace(new RegExp("" + $3, 'g'), '');
            if (todo === newtodo) {
              if (env.TODOTXT_VERBOSE > 0) {
                echo("" + item + " " + todo);
              }
              die("TODO: '" + $3 + "' not found; no removal done.");
            } else {
              todos = loadTodoFile(env.TODO_FILE);
              todos[item] = newtodo;
              saveTodoFile(todos, env.TODO_FILE);
            }
            if (env.TODOTXT_VERBOSE > 0) {
              echo("" + item + " " + todo);
              echo("TODO: Removed '" + $3 + "' from task.");
              echo("" + item + " " + newtodo);
            }
          }
          break;
        case 'depri':
        case 'dp':
          env.errmsg = "usage: " + env.TODO_SH + " depri ITEM#[, ITEM#, ITEM#, ...]";
          argv.shift();
          if (argv.length === 0) {
            die(env.errmsg);
          }
          _ref3 = argv.join(',').split(',');
          for (_l = 0, _len2 = _ref3.length; _l < _len2; _l++) {
            item = _ref3[_l];
            todo = getTodo(item);
            newtodo = todo.replace(/^\(.\) /, '');
            if (newtodo !== todo) {
              todos = loadTodoFile(env.TODO_FILE);
              todos[parseInt(item, 10)] = newtodo;
              saveTodoFile(todos, env.TODO_FILE);
              if (env.TODOTXT_VERBOSE > 0) {
                echo("" + item + " " + newtodo);
                echo("TODO: " + item + " deprioritized.");
              }
            } else {
              echo("TODO: " + item + " is not prioritized.");
            }
          }
          break;
        case 'do':
          env.errmsg = "usage: " + env.TODO_SH + " do ITEM#[, ITEM#, ITEM#, ...]";
          argv.shift();
          if (argv.length === 0) {
            die(env.errmsg);
          }
          todos = loadTodoFile();
          _ref4 = argv.join(',').split(',');
          for (_m = 0, _len3 = _ref4.length; _m < _len3; _m++) {
            item = _ref4[_m];
            todo = getTodo(item);
            if ((todo != null ? todo.slice(0, 2) : void 0) !== 'x ') {
              now = formattedDate();
              item = parseInt(item, 10);
              todos[item] = todos[item].replace(/^\(.\) /, '').replace(/^/, "x " + now + " ");
              saveTodoFile(todos);
              if (env.TODOTXT_VERBOSE > 0) {
                echo("" + item + " " + todos[item]);
                echo("TODO: " + item + " marked as done.");
              }
            } else {
              echo("TODO: " + item + " is already marked done.");
            }
          }
          if (env.TODOTXT_AUTO_ARCHIVE === 1) {
            run(['archive']);
          }
          break;
        case 'help':
          argv.shift();
          if (argv.length) {
            actionUsage(argv);
          } else {
            help();
          }
          break;
        case 'shorthelp':
          shorthelp();
          break;
        case 'list':
        case 'ls':
          argv.shift();
          _list(env.TODO_FILE, argv);
          break;
        case 'listall':
        case 'lsa':
          argv.shift();
          total = (_ref5 = ((_ref6 = loadTodoFile()) != null ? _ref6.length : void 0) - 1) != null ? _ref5 : 0;
          padding = String(total).length;
          todoItems = loadTodoFile(env.TODO_FILE);
          doneItems = loadTodoFile(env.DONE_FILE);
          allItems = todoItems.concat(doneItems);
          _format(allItems, padding, argv);
          if (env.TODOTXT_VERBOSE > 0) {
            tdone = doneItems.length - 1;
            echo = function() {};
            tasknum = _format(todoItems, padding, argv);
            donenum = _format(doneItems, padding, argv);
            echo = ui.echo;
            echo("--");
            echo("" + (getPrefix(env.TODO_FILE)) + ": " + tasknum + " of " + total + " tasks shown");
            echo("" + (getPrefix(env.DONE_FILE)) + ": " + donenum + " of " + tdone + " tasks shown");
            echo("total " + (tasknum + donenum) + " of " + (total + tdone) + " tasks shown");
          }
          break;
        case 'listfile':
        case 'lf':
          argv.shift();
          if (argv[0] == null) {

          } else {
            file = argv.shift();
            _list(file, argv);
          }
          break;
        case 'listcon':
        case 'lsc':
          file = loadSourceVarOrTodoFile();
          argv.shift();
          filters = filtercommand('', '', argv);
          file = applyFilters(filters, file.split('\n')).join('\n');
          if (contexts = file.match(/(^|\s)@[\x21-\x7E]+/g)) {
            contexts = (function() {
              var _len4, _n, _results;
              _results = [];
              for (_n = 0, _len4 = contexts.length; _n < _len4; _n++) {
                context = contexts[_n];
                _results.push(context.trim());
              }
              return _results;
            })();
            _ref7 = contexts.sort().unique();
            for (_n = 0, _len4 = _ref7.length; _n < _len4; _n++) {
              context = _ref7[_n];
              echo(context);
            }
          }
          break;
        case 'listproj':
        case 'lsprj':
          file = loadSourceVarOrTodoFile();
          argv.shift();
          filters = filtercommand('', '', argv);
          file = applyFilters(filters, file.split('\n')).join('\n');
          if (projects = file.match(/(^|\s)\+[\x21-\x7E]+/g)) {
            projects = (function() {
              var _len5, _o, _results;
              _results = [];
              for (_o = 0, _len5 = projects.length; _o < _len5; _o++) {
                project = projects[_o];
                _results.push(project.trim());
              }
              return _results;
            })();
            _ref8 = projects.sort().unique();
            for (_o = 0, _len5 = _ref8.length; _o < _len5; _o++) {
              project = _ref8[_o];
              echo(project);
            }
          }
          break;
        case 'listpri':
        case 'lsp':
          argv.shift();
          if (pri = (_ref9 = argv[0]) != null ? _ref9.toUpperCase().match(/^(([A-Z]\-[A-Z])|([A-Z]))$/) : void 0) {
            pri = pri[0];
            argv.shift();
          } else {
            pri = 'A-Z';
          }
          _list(env.TODO_FILE, argv, new RegExp('^ *[0-9]\+ \\([' + pri + ']\\) '));
          break;
        case 'prepend':
        case 'prep':
          env.errmsg = "usage: " + env.TODO_SH + " prepend ITEM# \"TEXT TO PREPEND\"";
          replaceOrPrepend('prepend', argv);
          break;
        case 'pri':
        case 'p':
          item = argv[1];
          newpri = (_ref10 = argv[2]) != null ? _ref10.toUpperCase() : void 0;
          env.errmsg = ("usage: " + env.TODO_SH + " pri ITEM# PRIORITY\n") + "note: PRIORITY must be anywhere from A to Z.";
          if (argv.length !== 3) {
            die(env.errmsg);
          }
          if (!/^[A-Z]/.test(newpri)) {
            die(env.errmsg);
          }
          todo = getTodo(item);
          oldpri = '';
          if (/^\([A-Z]\) /.test(todo)) {
            oldpri = todo[1];
          }
          if (oldpri !== newpri) {
            newtodo = todo.replace(/^\(.\) /, '').replace(/^/, "(" + newpri + ") ");
            if (todos = loadTodoFile()) {
              todos[parseInt(item)] = newtodo;
              saveTodoFile(todos);
            }
          }
          if (env.TODOTXT_VERBOSE > 0) {
            if (newtodo == null) {
              newtodo = todo;
            }
            echo("" + item + " " + newtodo);
            if (oldpri !== newpri) {
              if (oldpri) {
                echo("TODO: " + item + " re-prioritized from (" + oldpri + ") to (" + newpri + ").");
              } else {
                echo("TODO: " + item + " prioritized (" + newpri + ").");
              }
            }
            if (oldpri === newpri) {
              echo("TODO: " + item + " already prioritized (" + newpri + ").");
            }
          }
          break;
        case 'replace':
          env.errmsg = "usage: " + env.TODO_SH + " replace ITEM# \"UPDATED ITEM\"";
          replaceOrPrepend('replace', argv);
          break;
        case 'report':
          run(['archive']);
          total = (_ref11 = ((_ref12 = loadTodoFile()) != null ? _ref12.length : void 0) - 1) != null ? _ref11 : 0;
          tdone = (_ref13 = ((_ref14 = loadTodoFile(env.DONE_FILE)) != null ? _ref14.length : void 0) - 1) != null ? _ref13 : 0;
          newdata = "" + total + " " + tdone;
          lastreport = filesystem != null ? (_ref15 = filesystem.load(env.REPORT_FILE)) != null ? (_ref16 = _ref15.trim()) != null ? (_ref17 = _ref16.split('\n')) != null ? _ref17.pop() : void 0 : void 0 : void 0 : void 0;
          lastdata = lastreport.replace(/^[^ ]+ /, '');
          if (lastdata === newdata) {
            echo(lastreport);
            if (env.TODOTXT_VERBOSE > 0) {
              echo("TODO: Report file is up-to-date.");
            }
          } else {
            newreport = "" + (formattedDate(true)) + " " + newdata;
            filesystem.append(env.REPORT_FILE, newreport);
            echo("" + newreport);
            if (env.TODOTXT_VERBOSE > 0) {
              echo("TODO: Report file updated.");
            }
          }
          break;
        case 'deduplicate':
          todos = loadTodoFile();
          originalTaskNum = ((function() {
            var _len6, _p, _results;
            _results = [];
            for (_p = 0, _len6 = todos.length; _p < _len6; _p++) {
              t = todos[_p];
              if (t !== '') {
                _results.push(t);
              }
            }
            return _results;
          })()).length - 1;
          for (i = _p = 0, _len6 = todos.length; _p < _len6; i = ++_p) {
            item = todos[i];
            for (d = _q = 0, _len7 = todos.length; _q < _len7; d = ++_q) {
              dupe = todos[d];
              if (item === dupe && d > i) {
                todos[d] = DUPE_PLACEHOLDER;
              }
            }
          }
          if (env.TODOTXT_PRESERVE_LINE_NUMBERS === 0) {
            todos = (function() {
              var _len8, _r, _results;
              _results = [];
              for (_r = 0, _len8 = todos.length; _r < _len8; _r++) {
                t = todos[_r];
                if (t !== DUPE_PLACEHOLDER) {
                  _results.push(t);
                }
              }
              return _results;
            })();
          } else {
            for (i = _r = 0, _len8 = todos.length; _r < _len8; i = ++_r) {
              todo = todos[i];
              if (todo === DUPE_PLACEHOLDER) {
                todos[i] = '';
              }
            }
            while (todos[todos.length - 1] === '') {
              todos.length--;
            }
          }
          newTaskNum = ((function() {
            var _len9, _results, _s;
            _results = [];
            for (_s = 0, _len9 = todos.length; _s < _len9; _s++) {
              t = todos[_s];
              if (t !== '') {
                _results.push(t);
              }
            }
            return _results;
          })()).length - 1;
          deduplicateNum = originalTaskNum - newTaskNum;
          if (deduplicateNum === 0) {
            echo("TODO: No duplicate tasks found");
          } else {
            echo("TODO: " + deduplicateNum + " duplicate task(s) removed");
            saveTodoFile(todos);
          }
          break;
        default:
          usage();
      }
      return 0;
    };
    return {
      init: init,
      run: run
    };
  });

}).call(this);
